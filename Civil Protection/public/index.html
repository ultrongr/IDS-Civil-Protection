<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Emergency Map — AMEA + Fleet + Disasters</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .legend { background: #fff; padding: 8px 10px; line-height: 1.2; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,.2); }
    .legend .dot { display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; }

    .leaflet-control.custom-btns { background: #fff; padding: 6px; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,.3); }
    .leaflet-control.custom-btns button { display:block; width: 160px; margin: 4px 0; padding: 6px 8px; font: 12px/14px system-ui, Arial, sans-serif; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; }
    .leaflet-control.custom-btns button:hover { background:#f6f6f6; }

    /* Vehicles list (inside the same control) */
    .veh-wrap { margin-top: 6px; }
    .veh-wrap details { border: 1px solid #e6e6e6; border-radius: 6px; padding: 4px 6px; }
    .veh-wrap summary { cursor: pointer; font: 12px/14px system-ui, Arial, sans-serif; user-select: none; }
    .veh-tools { display:flex; gap:6px; margin:6px 0 4px; }
    .veh-tools button { flex:1; font-size: 11px; padding: 4px 6px; }
    .veh-list { max-height: 180px; overflow: auto; padding-right: 4px; }
    .veh-item { display:flex; align-items:center; gap:6px; padding: 3px 2px; font: 12px/14px system-ui, Arial, sans-serif; }
    .veh-chip { width:10px; height:10px; border-radius:50%; flex: 0 0 auto; border: 1px solid rgba(0,0,0,.2); }
    .veh-plate { font-weight: 600; }
    .veh-dim { color:#666; font-weight: 400; }

    .pickup-label {
      color: #fff; border-radius: 12px; padding: 2px 6px; font: 11px/13px system-ui, Arial, sans-serif;
      border: 2px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,.35);
    }
    .leaflet-div-icon{ background:transparent; border:none; }

    .vehicle-wrap { display: grid; place-items: center; width: auto; height: auto; background: transparent; border: none; box-shadow: none; }
    .vehicle-wrap .car{ width:20px; height:20px; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
          crossorigin=""></script>
  <script>
    // Map (SVG renderer; keep default)
    let fleetLocked = false; // when true, do NOT refresh vehicle positions

    const map = L.map('map').setView([38.0, 23.7], 7);
    let selectedVehicleIds = new Set();

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap' }).addTo(map);

    // Panes for z-order
    map.createPane('pane-disasters');  map.getPane('pane-disasters').style.zIndex = 420;
    map.createPane('pane-amea');       map.getPane('pane-amea').style.zIndex      = 450;
    map.createPane('pane-fleet');      map.getPane('pane-fleet').style.zIndex     = 460;
    map.createPane('pane-routes');     map.getPane('pane-routes').style.zIndex    = 470;

    map.createPane('pane-pickups');
    map.getPane('pane-pickups').style.zIndex = 480; // higher than routes


    function circle(color) {
      return { radius: 6, weight: 1, opacity: 1, fillOpacity: 0.9, color: '#222', fillColor: color };
    }
    function dangerColor(lvl) {
      const t = String(lvl || '').toLowerCase();
      if (t.includes('extreme')) return '#e74c3c';
      if (t.includes('high'))    return '#e67e22';
      if (t.includes('moderate'))return '#f1c40f';
      if (t.includes('low'))     return '#2ecc71';
      return '#3498db';
    }
    // Deterministic "random" color per vehicle
    function colorForKey(key = '') {
      let h = 0 >>> 0;
      for (let i = 0; i < key.length; i++) h = (h * 2654435761 + key.charCodeAt(i)) >>> 0;
      const hue = h % 360;
      return `hsl(${hue}, 78%, 45%)`;
    }

    function colorFromType(type) {
      if (type === 'ambulance') return '#fff200';
      if (type === 'fire_truck') return '#ff0d13';
      if (type === 'police_car') return '#146dd1';
      console.log('Unknown vehicle type:', type);
      return '#ffffff';
    }

    const layers = {
      disasters: L.layerGroup([], { pane: 'pane-disasters' }).addTo(map),
      amea:      L.layerGroup([], { pane: 'pane-amea'      }).addTo(map),
      fleet:     L.layerGroup([], { pane: 'pane-fleet'     }).addTo(map),
      routes:    L.layerGroup([], { pane: 'pane-routes'    }).addTo(map),
    };

    // --- NEW: track latest fleet for UI rendering ---
    let fleetLatest = []; // array of GeoJSON features (fleet)
    // Map vehicleId -> L.Marker
    const fleetMarkers = new Map();

    let didInitialFit = false;
    let lastBounds = L.latLngBounds([]);

    function renderPopup(kind, p) {
      if (kind === 'fleet') {
        return `<b>Vehicle</b><br/>ID: ${esc(p.id)}<br/>Plate: ${esc(p.license_plate)}<br/>Type: ${esc(p.type)}<br/>Speed: ${esc(String(p.speed))}`;
      }
      if (kind === 'amea') {
        return `<b>AMEA</b><br/>${esc(p.name || 'Unknown')}<br/>Disability %: ${esc(String(p.disabilityPct ?? '-'))}<br/>Phone: ${esc(p.phone ?? '-')}` +
              `<br/>Email: ${esc(p.email ?? '-')}`;
      }

      // --- disasters
      const dt = v => (v ? new Date(v).toLocaleString('el-GR') : '—');

      // SPECIAL: projected areas get a different popup
      if ((p.kind || '') === 'projected') {
        return `<b>Evacuation area</b><br/>
                Risk level: ${esc(p.dangerLevel || p.severity || '-') }<br/>
                Effective from: ${esc(dt(p.startDate || p.startedAt || p.timestamp))}<br/>
                Until: ${esc(dt(p.endDate))}<br/>
                Source: ${esc(p.source || '-')}`;
      }

      // Default disaster popup
      return `<b>Disaster</b><br/>
              Type: ${esc(p.type || 'event')}<br/>
              Danger: ${esc(p.dangerLevel || p.severity || '-') }<br/>
              Start: ${esc(dt(p.startDate || p.startedAt || p.timestamp))}<br/>
              End: ${esc(dt(p.endDate))}<br/>
              Source: ${esc(p.source || '-')}`;
    }

    function esc(s) { return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
    function vehicleIcon(props = {}, size = 36) {
      // const body = colorForKey(String(props.license_plate || props.id || ''));
      const body = colorFromType(props.type)
      const s = size;               // overall marker size (px)
      const a = Math.round(s / 2);  // anchor (center)
      const html = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" width="${s}" height="${s}" aria-hidden="true">
        <g stroke="rgba(0,0,0,.35)" stroke-width="1.2">
          <path d="M8 24c0-1 .6-1.9 1.6-2.3l6.5-2.6c.5-.2 1-.3 1.5-.3h12.8c.5 0 1 .1 1.5.3l6.5 2.6C39.4 22.1 40 23 40 24v7.5
                  c0 1.1-.9 2-2 2h-1.8a6 6 0 0 1-12 0h-4.4a6 6 0 0 1-12 0H8c-1.1 0-2-.9-2-2V24z" fill="${body}" />
          <rect x="15" y="19" width="8" height="3.2" rx="0.6" fill="rgba(255,255,255,.9)" stroke="none"/>
          <rect x="25" y="19" width="8" height="3.2" rx="0.6" fill="rgba(255,255,255,.9)" stroke="none"/>
          <circle cx="16" cy="34" r="4.4" fill="#222"/>
          <circle cx="32" cy="34" r="4.4" fill="#222"/>
        </g>
      </svg>`;
      return L.divIcon({ className: 'leaflet-div-icon veh-marker', html, iconSize: [s, s], iconAnchor: [a, a] });

    }

    function addFeatureCollection(fc, kind) {
      if (!fc) return;

    if (kind === 'disasters') {
      if (fc.type === 'FeatureCollection' && Array.isArray(fc.features)) {
        const projectedFC = { type: 'FeatureCollection',
          features: fc.features.filter(f => (f.properties || {}).kind === 'projected') };
        const mainFC = { type: 'FeatureCollection',
          features: fc.features.filter(f => (f.properties || {}).kind !== 'projected') };

        const styleFn = (feature) => {
          const p = feature?.properties || {};
          const color = dangerColor(p.dangerLevel || p.severity || 'moderate');
          return p.kind === 'projected'
            ? { weight:1, opacity:0.8, color, dashArray:'6,6', fillOpacity:0.20, fillColor:color }
            : { weight:2, opacity:1,  color,                 fillOpacity:0.35, fillColor:color };
        };

        // ⬇️ Add THIS onEach right here
        const onEach = (feature, layer) => {
          const props = feature.properties || {};
          layer.bindPopup(renderPopup('disasters', props));

          // --- hover tooltips ---
          if (props.kind === 'projected') {
            layer.bindTooltip('Evacuation area', { sticky: true, direction: 'top', opacity: 0.9 });
          } else {
            const t = props.type || 'Disaster';
            const danger = props.dangerLevel || props.severity || '';
            const label = danger ? `${t} — ${danger}` : t;
            layer.bindTooltip(label, { sticky: true, direction: 'top', opacity: 0.9 });
          }

          // --- hover highlight (optional but nice) ---
          const applyHover = () => {
            if (props.kind === 'projected') {
              layer.setStyle({ weight: 2, fillOpacity: 0.30 });
            } else {
              layer.setStyle({ weight: 3, fillOpacity: 0.45 });
            }
          };
          const resetStyle = () => {
            // restore base style using the same function you used in L.geoJSON
            layer.setStyle(styleFn(feature));
          };
          layer.on('mouseover', applyHover);
          layer.on('mouseout', resetStyle);

          // keep the focus-rectangle fixes
          layer.on('add', () => {
            const el = layer.getElement?.();
            if (el) {
              el.removeAttribute('tabindex');
              el.setAttribute('tabindex', '-1');
              el.setAttribute('focusable', 'false');
              el.style.outline = 'none';
            }
          });
          layer.on('click', () => {
            const ae = document.activeElement;
            if (ae && ae !== document.body) ae.blur();
          });
        };

        // add projected first (under)
        const projectedLayer = L.geoJSON(projectedFC, {
          pane: 'pane-disasters',
          interactive: true,
          style: styleFn,
          onEachFeature: onEach
        });
        layers.disasters.addLayer(projectedLayer);

        // add main perimeters second (over)
        const mainLayer = L.geoJSON(mainFC, {
          pane: 'pane-disasters',
          interactive: true,
          style: styleFn,
          onEachFeature: onEach
        });
        layers.disasters.addLayer(mainLayer);

        try {
          if (projectedLayer.getBounds().isValid()) lastBounds.extend(projectedLayer.getBounds());
          if (mainLayer.getBounds().isValid())      lastBounds.extend(mainLayer.getBounds());
        } catch {}
      }
      return;
    }


      if (!Array.isArray(fc.features)) return;
      const color = (kind === 'fleet') ? '#2b8eff' : '#a12bff';
      const paneName = (kind === 'fleet') ? 'pane-fleet' : 'pane-amea';

      // --- NEW: if fleet, remember the features for the UI list ---
      if (kind === 'fleet') fleetLatest = fc.features.slice();

      for (const f of fc.features) {
        const c = f.geometry?.coordinates;
        if (!c || c.length !== 2) continue;
        const latlng = L.latLng(c[1], c[0]);
        const props = f.properties || {};
        let marker;
        if (kind === 'fleet') {
          marker = L.marker(latlng, {
            pane: paneName,
            icon: vehicleIcon(props, 36),
            title: String(props.license_plate || props.id || 'Vehicle')
          });
        } else {
          marker = L.circleMarker(latlng, { ...circle(color), pane: paneName });
        }
        marker.bindPopup(renderPopup(kind, props));
        layers[kind].addLayer(marker);
        // remember this marker by vehicle id
        const id = String(props.id || '');
        fleetMarkers.set(id, marker);

        // ensure the correct dim state once it's on the map
        marker.once('add', () => applyFleetDim());

        lastBounds.extend(latlng);
      }
    }

    async function refreshAll() {
      try {
        const ts = Date.now();

        // Fetch disasters + AMEA always; fetch fleet only if not locked
        const [disR, ameaR, fleetR] = await Promise.all([
          fetch('/api/disasters?active=true&ts=' + ts, { cache: 'no-store' }),
          fetch('/api/amea?ts=' + ts,                 { cache: 'no-store' }),
          fleetLocked ? null : fetch('/api/fleet?ts=' + ts, { cache: 'no-store' })
        ]);

        const [disasters, amea, fleet] = await Promise.all([
          disR.json(),
          ameaR.json(),
          fleetLocked ? Promise.resolve(null) : fleetR.json()
        ]);

        layers.disasters.clearLayers();
        layers.amea.clearLayers();
        if (!fleetLocked) {
          layers.fleet.clearLayers();
          fleetMarkers.clear();
        }
        lastBounds = L.latLngBounds([]);

        addFeatureCollection(disasters, 'disasters');
        addFeatureCollection(amea,      'amea');
        if (!fleetLocked && fleet) addFeatureCollection(fleet, 'fleet');

        renderVehicleList();
        applyFleetDim();

        if (!didInitialFit && lastBounds.isValid()) {
          map.fitBounds(lastBounds.pad(0.1));
          didInitialFit = true;
        }
      } catch (e) {
        console.error('Failed to refresh layers', e);
      }
    }

    // --- Routes drawing ---
    function clearRoutes() { layers.routes.clearLayers(); }
    function drawRoutes(fc) {
      clearRoutes();
      if (!fc || !Array.isArray(fc.features)) return;
      const routeLayer = L.geoJSON(fc, {
        pane: 'pane-routes',
        style: (f) => {
          if (f.properties?.kind !== 'route') return undefined;
          const p = f.properties;
          // const color = colorForKey(String(p.license_plate || p.vehicleId || ''));
          const color = colorFromType(p.type);
          
          return { color, weight: 7, opacity: 0.95 };
        },
        pointToLayer: (f, latlng) => {
          const p = f.properties || {};
          if (p.kind === 'pickup') {
            const color = colorFromType(p.type);
            const html = `<div class="pickup-label" style="background:${color}">${p.seq ?? ''}</div>`;
            return L.marker(latlng, {
              pane: 'pane-pickups', // ⬅️ use pickup pane instead of pane-routes
              icon: L.divIcon({
                className: '',
                html,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
              })
            });
          }
          return L.circleMarker(latlng, { ...circle('#000'), pane: 'pane-routes' });
        },
        onEachFeature: (feature, layer) => {
          if (feature.properties?.kind === 'route') {
            const p = feature.properties;
            layer.bindPopup(
              `<b>Route</b> — Vehicle: ${esc(p.license_plate || p.vehicleId)}<br/>` +
              `Stops: ${esc(p.assigned ?? 0)}<br/>Distance: ${esc(p.distanceKm ?? '-') } km`
            );
          } else if (feature.properties?.kind === 'pickup') {
            const p = feature.properties;
            layer.bindPopup(
              `<b>Pickup #${esc(p.seq)}</b><br/>Vehicle: ${esc(p.license_plate || p.vehicleId)}<br/>` +
              `Name: ${esc(p.name || 'AMEA')}`
            );
          }
        }
      });
      layers.routes.addLayer(routeLayer);
      try {
        const b = routeLayer.getBounds();
        if (b.isValid()) map.fitBounds(b.pad(0.2));
      } catch {}
    }

      // --- NEW: plan with selected vehicles ---
      function getSelectedVehicleIds() {
        const box = document.getElementById('veh-list-box');
        if (!box) return [];
        return Array.from(box.querySelectorAll('input[type="checkbox"][data-veh-id]:checked'))
          .map(el => el.getAttribute('data-veh-id'));
      }

      function getSelectedVehicleIdsSet() {
    const box = document.getElementById('veh-list-box');
    if (!box) return new Set();
    return new Set(
      Array.from(box.querySelectorAll('input[type="checkbox"][data-veh-id]:checked'))
        .map(el => el.getAttribute('data-veh-id'))
    );
  }

  function setMarkerDim(marker, dim) {
    const el = marker.getElement();
    if (!el) return; // not on map yet
    // console.log("toggle dim",  dim);
    // el.classList.toggle('is-dim', !!dim);
    if(!!dim){
      // el.classList.add('is-dim');
      el.style.opacity = '0.7';
      el.style.filter = 'grayscale(70%)';
    } else {
      el.style.opacity = '';
      el.style.filter = '';
    }
    // console.log(el.classList)
  }

  function applyFleetDim() {
    // console.log('applyFleetDim');
    const selected = getSelectedVehicleIdsSet();
    const anySelected = selected.size > 0;
    // If there are selections: dim those NOT selected.
    // If none selected: dim ALL.
    for (const [id, marker] of fleetMarkers.entries()) {
      const dim = anySelected ? !selected.has(id) : true;
      // console.log(id, dim);
      setMarkerDim(marker, dim);
    }
  }


    async function planRoutes() {
      try {
        const include = getSelectedVehicleIds();
        const r = await fetch('/api/plan-routes', {
          method: 'POST',
          headers: { 'Content-Type':'application/json' },
          body: JSON.stringify({ include }) // <- server will filter to these IDs (or all if empty)
        });
        const fc = await r.json();
        drawRoutes(fc);
        if (fc?.meta) console.log('Route meta:', fc.meta);
      } catch (e) {
        console.error('Plan routes failed', e);
      }
    }

    // --- UI: legend + buttons + VEHICLE LIST ---
    const legend = L.control({position:'topright'});
    legend.onAdd = function() {
      const div = L.DomUtil.create('div', 'legend');
      div.innerHTML = `
        <div><span class="dot" style="background:#ff3b30"></span> Disasters</div>
        <div><span class="dot" style="background:#a12bff"></span> AMEA</div>
        <div><span class="dot" style="background:#fff200"></span> Ambulance</div>
        <div><span class="dot" style="background:#146dd1"></span> Police Car</div>
        <div><span class="dot" style="background:#ff0d13"></span> Fire Truck</div>`;
      return div;
    };
    legend.addTo(map);

    // --- NEW: vehicles list renderer ---
    let vehListContainer = null;
    function renderVehicleList() {
      if (!vehListContainer) return; // created in Buttons.onAdd
      const box = vehListContainer.querySelector('#veh-list-box');
      if (!box) return;

      
      // Use the global selectedVehicleIds
      const prevSelected = selectedVehicleIds;


      box.innerHTML = '';
      // Sort by plate then id for readability
      const sorted = fleetLatest.slice().sort((a,b) => {
        const ap = String(a.properties?.license_plate||'');
        const bp = String(b.properties?.license_plate||'');
        if (ap && bp && ap !== bp) return ap.localeCompare(bp);
        return String(a.properties?.id||'').localeCompare(String(b.properties?.id||''));
      });

      for (const f of sorted) {
        const p = f.properties || {};
        const id = String(p.id || '');
        const plate = String(p.license_plate || '—');
        // const chipColor = colorForKey(plate || id);
        const chipColor = colorFromType(p.type);

        const row = document.createElement('label');
        row.className = 'veh-item';
        row.innerHTML = `
          <input type="checkbox" data-veh-id="${esc(id)}">
          <span class="veh-chip" style="background:${chipColor}"></span>
          <span class="veh-plate">${esc(plate)}</span>
          <span class="veh-dim">(${esc(id)})</span>
        `;
        const cb = row.querySelector('input');
        cb.checked = prevSelected.has(id);
        cb.addEventListener('change', () => {
          if (cb.checked) selectedVehicleIds.add(id);
          else selectedVehicleIds.delete(id);
          applyFleetDim();
        });

        box.appendChild(row);

        
      }
    }

    const Buttons = L.Control.extend({
      onAdd: function() {
        const div = L.DomUtil.create('div', 'leaflet-control custom-btns');

        const plan = L.DomUtil.create('button', '', div);
        plan.textContent = 'Plan pickups';
        plan.onclick = (e) => { 
          e.preventDefault(); 
          fleetLocked = true;         // ⛔ stop updating vehicle positions
          planRoutes(); 
        };


        const clr = L.DomUtil.create('button', '', div);
        clr.textContent = 'Clear routes';
        clr.onclick = (e) => { 
          e.preventDefault(); 
          clearRoutes(); 
          fleetLocked = false;        // ✅ resume updates
          refreshAll();               // pull latest positions immediately
        };


        // --- NEW: Vehicles list (inside same control) ---
        const wrap = L.DomUtil.create('div', 'veh-wrap', div);
        wrap.innerHTML = `
          <details open>
            <summary>Vehicles</summary>
            <div class="veh-tools">
              <button type="button" id="veh-all">All</button>
              <button type="button" id="veh-none">None</button>
            </div>
            <div id="veh-list-box" class="veh-list"></div>
          </details>
        `;
        vehListContainer = wrap;

        // Tool buttons
        wrap.querySelector('#veh-all').onclick = (e) => {
          e.preventDefault();
          selectedVehicleIds = new Set(fleetLatest.map(f => String(f.properties?.id || '')));
          renderVehicleList();
          applyFleetDim();
        };
        wrap.querySelector('#veh-none').onclick = (e) => {
          e.preventDefault();
          selectedVehicleIds.clear();
          renderVehicleList();
          applyFleetDim();
        };

        
        // Initial render (will fill on first refresh)
        renderVehicleList();

        // stop map drags when clicking
        L.DomEvent.disableClickPropagation(div);
        return div;
      },
      onRemove: function() {}
    });
    (new Buttons({ position: 'topleft' })).addTo(map);

    // Initial load + poll every 5s
    refreshAll();
    setInterval(refreshAll, 5000);
  </script>
</body>
</html>
